# 리펙터링이란
리펙터링은 겉으로 드러나는 코드의 기능은 바꾸지 않으면서 내부 구조를 개선하는 방식으로 
소프트웨어 시스템을 수정하는 과정

리펙터링을 한다는 것은 코드를 작성하고 난 뒤에 설계를 개선한다는 것

보통은 설계 후 코드를 작성하는 게 일반적인 방법이나
현실에서는 시간이 흐름에 따라 요구사항에 맞추어 개발하다보면 시스템의 무결성이 
깨지는 일이 비일비재 하다.

그래서 이 과정을 반대로 하는것이 리팩토링인 것이다.

처음부터 완벽한 설계를 갖추기 보다는 개발을 진행하면서 지속적으로 설계한다.
시스템을 구축하는 과정에서 더 나은 설계가 무엇인지 배우게 된다.
그 결과, 개발의 시작부터 끝날 때까지 줄곧 우수한 설계를 유지하게 된다.

책 정보 깃허브 주소  
https://github.com/WegraLee/Refactoring  

코드 샘플 깃허브 주소  
https://github.com/wickedwukong/martin-fowler-refactoring-2nd  

프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 
리펙타링하고 나서 원하는 기능을 추가한다.

컴파일러는 리펙터링을 신경쓰지 않는다. 
사람이 코딩하기 때문에 리펙토링이 필요하다. 누군가는 내 코드를 읽고 작업해야하기 때문

리팩타링이 필요한 이유는 결국 계속 변경되는 요구사항에 맞춰 구현 할 수 있도록 하기 위함이다.

리펙터링의 첫단계 테스트 코드?!
왜냐 리팩터링은 작동하는 코드를 수정하는 것이기 때문에 버그 리스크를 항상 감수해야 하기 때문이다.

리펙터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

리펙터링시 테스트에 상당히 의지한다. 테스트 강조!! (컴파일-테스트-커밋)
리펙터링은 작은 단계로 나누어서 진행해야 한다. 그래야 버그 생겨도 쉽게 대응 가능


함수 안의 전체 동작을 각각 부분으로 나눈다.

- 함수 추출하기 - 코드 조각을 함수화 하는 것
  함수명으로 이 함수의 역할을 직관적으로 표시 + 리턴값 변수는 항상 result로 통일
  매개변수의 역할이 뚜렷하지 않으면 (a/an) 부정관사를 붙인다.

- 임시 변수를 질의 함수로 바꾸기 - 변수 우변 값을 함수화
  임시변수가 많을 경우 그만큼 추출 작업이 어려워진다. 임시 변수는 그 루틴 안에서만
  의미가 있기 때문에 존재 자체로 루틴을 복잡하게 만들기 쉽다. 그러므로 제거하는게 유리하다.

- 변수 인라인하기 - 함수화된 함수를 변수 할당 없이 직접 전달

- 함수 선언 바꾸기 - 매개변수를 함수 호출로 변경

- 함수 변수를 일반 함수로 추출하기 

- 반복문 쪼개기 - for문 안에 n개의 로직을 각각 for문으로 쪼개기

- 문장 슬라이드 하기 - 변수 초기화 문장을 변수값 누적 코드 바로 앞으로 롬긴다.

리펙터링 초기 단계에는 프로그램의 논리적인 요소를 파악하기 쉽도록(가독성) 코드의 구조를
보강하는데 주안점을 두고 리펙터링했다.

구조 개선 뒤 본격적인 기능 변경 작업을 한다. (HTML 포맷팅)

- 단계 쪼개기 - 예시 기준으로는 첫 단계로 데이터 처리 두 번째 단계로 데이터 포맷팅

- 함수 옮기기 - 함수 상위든 하위든 선언 부 위치 이동

- 반복문을 파이프라인으로 바꾸기 - for문 -> reduce()로 변경
  
  ```
  // for문  
  for(let perf of data.performances) {  
    result += `  ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;  
  }  

  // reduce문  
  data.performances.reduce((total, p) => total + p.amount, 0);

  가장 대표적인 reduce 사용 방법은 Array내 원소의 누적 합을 구하는 것이다.  
  const arr = [1, 2, 3, 4, 5];  
  const result = arr.reduce((acc, cur) => { 
    return acc + cur;  
  }, 0);
  console.log(result); // 15  
  ```
  
모듈화를 통하여 계산 로직과 출력 로직을 분리 -> 리펙터링을 통해 코드 베이스를 건강하게 만든다는 것

다형성 활용한 계산 코드 재구성
다형성 - 오버라이딩, 오버로딩 동적으로 재활용 가능하게 하는 것

동적으로 변하는 부분을 클래스화 한다. 예시에선 공연료 계산기가 슈퍼 클래스

- 타입 코드를 서브 클래스로 바꾸기 - 동적 할당 로직 부분을 서브 클래스 인스턴스로 교체 

- 생성자를 팩토리 함수로 바꾸기 - 자바스크립트에서는 생성자가 서브클래스의 인스턴스를 반환 할 수 없기 때문에 이 기법 사용

- 조건부 로직을 다형성으로 바꾸기 - 슈퍼 클래스 메서드를 서브 클래스로 내리는 
  조건부 로직을 인스턴스 생성 함수로 옮기는 것

이번 장에서는 리펙터링을 크게 3단계로 진행했다. 
1. 원본 함수를 중첩 함수 여러 개로 나누기
2. 단계 쪼개기를 통해 계산 코드와 출력 코드 구분
3. 계산 로직 다형성으로 표현

리펙터링은 대부분 코드가 하는 일을 파악하는데서 시작한다. 그래서 코드를 읽고, 개선점을 찾고, 리펙터링 작업을 통해
개선점을 코드에 반영하는 식으로 진행한다. 그 결과 코드가 명확해지고 이해하기 더 쉬워진다. 

"좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다"

코드 수정해야 할 상황에 쉽게 수정 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정 할 수 있어야 한다.
건강한 코드 베이스는 생산성을 극대화하고, 고객에게 필요한 기능을 더 빠르고 저렴한 비용으로 제공하도록 해준다.

건강한 코드 베이스 관리를 위해 현재 소스와 이상적인 소스의 차이에 항상 신경 쓰면서, 이상에 가까워지도록 리펙터링해야 한다.

리펙터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리 할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은
단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. 
