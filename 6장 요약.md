# chapter 6 기본적인 리팩터링

***

카탈로그의 첫머리는 가장 기본적이고 많이 사용해서 제일 먼저 배워야 하는 리팩터링들로 시작한다.

이제부터 리팩터링의 기법들을 하나씩 소개할건데 가장 기본적이고 많이 사용하는 리팩토링부터 배워보자.

내가 가장 많이 사용하는 리팩토링 기법은 __함수 추출하기 (6.1절)__ 과 __변수 추출하기 (6.3절)__ 이다.

리팩터링은 원래 코드를 변경하는 작업인 만큼 이 두 리팩토링을 반대로 변경하는 기법도 있다. __함수 인라인하기 (6.2절)__ 과 __변수 인라인하기 (6.4절)__ 도 자주 사용한다.

__추출 한다는 건 결국 이름짓기 이다.__

코드 이해도가 높아지다 보면 이름을 바꿔야 할 때가 많다.

__함수 선언 바꾸기 (6.5절)__ 는 함수의 이름을 변경할 때, 함수의 인수를 추가하거나 제거할 때 많이 쓰인다.

바꿀 대상이 변수라면 __변수 이름 바꾸기 (6.7절)__ 기법을 사용하고 이는 __변수 캡슐화하기 (6.8절)__ 과 관련이 깊다.

자주 함께 뭉쳐다니는 인수들은 __매개변수 객체 만들기 (6.8절)__ 기법을 적용해서 객체를 하나로 묶으면 편리할 때가 많다.

이렇게 이름을 짓거나 바꾸는 건 가장 기본적인 리팩토링이다.

이 다음으로는 함수를 만들면 함수들을 모듈로 묶는 __여러 함수를 클래스로 묶기 (6.9절)__ 을 이용할 수도 있다.

또 다른 함수를 묶는 방법으로는 __여러 함수를 변환 함수로 묶기 (6.10절)__ 도 있는데 이는 읽기 전용 데이터를 다룰 때 특히 좋다.

그 다음 단계로는 모듈로 만들었으면 명확히 모듈끼리 단계를 구분짓는 __단계 쪼개기 (6.11절)__ 기법을 적용하는 것도 가능하다.

__(정리하자면 가장 기본적인 리팩토링 기법은 추출하고 이름을 지어주거나, 이름을 변경해서 보다 좋은 코드를 만들도록 하고 그 코드들을 하나로 묶어서 모듈로 만드는 것. 마지막으로 모듈끼리 단계를 구분짓기?)___

***

## 6.2 함수 인라인 하기(Inline Function)

### 배경
- 때로는 함수 본문이 이름만큼 명확한 경우도 있다.
- 간접 호출은 유용할 수도 있지만, 쓸데없는 간접 호출은 거슬릴 뿐이다.
- 리팩터링 과정에서 잘못 추출된 함수들도 다시 인라인한다.
- 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게 얽혀 있으면 인라인해버린다.

### 적용 시점
- 함수 본문이 이름만큼 명확한 경우
- 간접 호출을 너무 과하게 쓰는 코드 (단순히 위임하기만 하는 함수들이 많아 복잡하게 얽힌 경우)

### 절차

이 기법을 적용하는 순서는 다음과 같다.

1. 다형 메소드 인지 확인한다(서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다). 

2. 인라인 할 함수를 호출하는 곳을 모두 찾아서 교체한다.

3. 인라인 하기 까다로운 부분이 있다면 이를 남겨놓고 가볍게 바꿀 수 있는 부분부터 바꾼다.

4. 함수 선언부를 제거한다.

### 효과
- 유용한 것만 남기고 불필요한 메서드를 제거할 수 있다

### 예시
```javascript
function rating(aDriver) {
  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(aDriver) {
  return aDriver.numberOfLateDeliveries > 5;
}

/**
 * 호출되는 함수의 반환문을 그대로 호출하는 함수를 덮는다.
 */
function rating(aDriver) {
  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;
}

/**
 * 다른 예시 (호출할 때 전달하는 인수 이름이 함수 정의에 쓰인 이름과 다른 경우)
 */
function rating(aDriver) {
  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(dvr) {
  return dvr.numberOfLateDeliveries > 5;
}

/**
 * 인라인 후 코드를 살짝 수정해야한다
 */
function rating(aDriver) {
  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;
}

/**
 * 더 복잡한 예시
 */
function reportLines(aCustomer) {
  const lines = [];
  gatherCustomerData(lines, aCustomer);
  return lines;
}

function gatherCustomerData(out, aCustomer) {
  out.push(["name", aCustomer.name]);
  out.push(["location", aCustomer.location]);
}

/**
 * 실수하지 않기 위해 한 번에 한 문장씩 옮기는 것이 좋다.
 */
function reportLines(aCustomer) {
  const lines = [];
  line.push(["name", aCustomer.name]);
  gatherCustomerData(lines, aCustomer);
  return lines;
}

function gatherCustomerData(out, aCustomer) {
  out.push(["location", aCustomer.location]);
}

/**
 * 나머지 문장도 같은 식으로 처리한다.
 */
function reportLines(aCustomer) {
  const lines = [];
  line.push(["name", aCustomer.name]);
  line.push(["location", aCustomer.location]);
  return lines;
}
```

## 6.3 변수 추출하기(Extract Variable)

### 배경

- 표현식이 너무 복잡해서 이해하기 어려울 때, 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다.
- 추가한 변수는 디버거에 중단점을 지정하거나 상태를 출력하는 문장을 추가할 수 있어서 디버깅에도 도움이 된다.
- 변수 추출을 고려한다고 함은 표현식에 이름을 붙이고 싶다는 뜻이다.

### 적용 시점
- 표현식이 복잡해서 이해하기 어려울 때

### 절차

이 기법의 순서는 다음과 같다. 

1. 추출하려는 표현식에 부작용은 없는지 확인한다.

2. 불변 변수를 선언하고 이름을 붙일 표현식의 복제본을 대입한다.

3. 원본 표현식을 새로 만든 변수로 교체한다.

4. 테스트한다.

5. 표현식을 여러 곳에서 사용한다면 각각 교체한다.

### 효과
- 코드의 목적을 명확하게 드러낼 수 있다.
- 디버깅에도 도움이 된다.

### 예시
ex1) 함수
```javascript
function price(order) {
  // 가격(price) = 기본 가격 - 수량 할인 + 배송비
  return (
    order.quantity * order.itemPrice -
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
    Math.min(order.quantity * order.itemPrice * 0.1, 100)
  );
}

/**
 * 기본 가격 변수 추출
 */
function price(order) {
  // 가격(price) = 기본 가격 - 수량 할인 + 배송비
  const basePrice = order.quantity * order.itemPrice;
  return (
    order.quantity * order.itemPrice -
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
    Math.min(order.quantity * order.itemPrice * 0.1, 100)
  );
}

/**
 * 해당 표현식을 변수로 교체
 */
function price(order) {
  // 가격(price) = 기본 가격 - 수량 할인 + 배송비
  const basePrice = order.quantity * order.itemPrice;
  return (
    basePrice -
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
    Math.min(basePrice * 0.1, 100)
  );
}

/**
 * 수량 할인 변수 추출 및 교체
 */
function price(order) {
  // 가격(price) = 기본 가격 - 수량 할인 + 배송비
  const basePrice = order.quantity * order.itemPrice;
  const quantityDiscount =
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
  return basePrice - quantityDiscount + Math.min(basePrice * 0.1, 100);
}

/**
 * 배송비 변수 추출 및 교체, 주석 제거
 */
function price(order) {
  const basePrice = order.quantity * order.itemPrice;
  const quantityDiscount =
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
  const shipping = Math.min(basePrice * 0.1, 100);
  return basePrice - quantityDiscount + shipping;
}
```
ex2) 클래스
```javascript
class Order {
  constructor(aRecord) {
    this._data = aRecord;
  }

  get quantity() {
    return this._data.quantity;
  }
  get itemPrice() {
    return this._data.itemPrice;
  }

  get price() {
    return (
      order.quantity * order.itemPrice -
      Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
      Math.min(order.quantity * order.itemPrice * 0.1, 100)
    );
  }
}

/**
 * price 메서드의 범위를 넘어 주문을 표현하는 Order 클래스 전체에 적용되므로
 * 변수가 아닌 메서드로 추출
 */
class Order {
  constructor(aRecord) {
    this._data = aRecord;
  }

  get quantity() {
    return this._data.quantity;
  }
  get itemPrice() {
    return this._data.itemPrice;
  }

  get price() {
    return this.basePrice - this.quantityDiscount + this.shipping;
  }
  get basePrice() {
    return this.quantity * this.itemPrice;
  }
  get quantityDiscount() {
    return Math.max(0, this.quantity - 500) * this.itemPrice * 0.05;
  }
  get shipping() {
    return Math.min(this.basePrice * 0.1, 100);
  }
}
```
